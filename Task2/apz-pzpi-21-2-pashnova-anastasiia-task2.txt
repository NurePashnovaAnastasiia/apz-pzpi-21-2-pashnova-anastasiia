1 МОДЕЛЮВАННЯ ПРОГРАМНОЇ СИСТЕМИ
1.1 Мета роботи



Метою даної лабораторної роботи є розробка серверної частини програмної інформаційної системи для управління закладами харчування «LightServe»; наведення опису прийнятих інженерних рішень; представлення загальної архітектури системи; показ будови серверних компонентів та структури бази даних.


1.2 Моделювання програмної системи


Аби почати створювати серверну частину програмної інформаційної системи для покращення управління закладами харчування «LightServe», варто провести аналіз предметної області. Отже, за допомогою програмої інформаційної системи «LightServe», користувачі, а саме власник закладу харчування зможе зареєструватися і в подальшому авторизуватись в системі, а також додавати, видаляти, змінювати та переглядати інформацію щодо таких сутностей, як: заклад харчування, робітники, меню, страва, столи; робітник, як користувач у свою чергу зможе авторизуватись за допомогою нікнейму та паролю, який надасть йому власник закладу і в подальшому змінити цей пароль, змінювати статус замовлення, змінювати статус столику, отримувати замовлення зроблені онлайн; відвідувач закладу харчування, як користувач зможе зареєструватися і в подальшому авторизуватись в системі, переглянути меню, страви, наявність доступних столиків, а також зробити, редагувати та видаляти замовлення.
Відповідно до наведеного вище аналізу, було створено діаграми прецедентів для користувачів: робітника (див. рис. А.1) власника закладу харчування (див. рис. А.2) і відвідувача закладу харчування (див. рис. А.3). 


2 ПРОЄКТУВАННЯ БАЗИ ДАНИХ


Аби почати створювати базу даних для програмної інформаційної системи для управління закладами харчування «LightServe», було створено діаграму ER-модель даних (див. рис. А.4). Було створено 9 таблиць, які містять 31 атрибут.
Визначено, що один власник може мати безліч закладів харчування, в той час як кожен заклад харчування може бути пов'язаний лише з одним власником.
Також передбачено, що заклад харчування може мати безліч робітників, і, відповідно, один робітник може належати лише одному закладу харчування.
Визначено, що меню може мати безліч страв, а кожна страва може бути пов'язана лише з одним меню.
Визначено, що столик може належити одному закладу харчування, а один заклад харчування може мати безліч столиків.
Зв'язки між стравами та замовленнями в системі визначають, що кожна страва може бути у безлічі замовленнях, і, відповідно, кожне замовлення може містити безліч страв. Створився зв'язок багато до багатьох, тому було створено додатково таблицю Деталі замовлення, яка розділяє цей зв'язок.
Окрім того, в моделі передбачено структуру для відвідувачів та замовлень. Один відвідувач може створити безліч замовлень, проте одне замовлення стосується одного відвідувача.
Крім того, у моделі враховано зв'язки між закладом харчування та замовденнями. Один заклад харчування може мати безліч замовлень і одне замовлення може належати одному закладу харчування. 
У підсумку, ER-модель даних «LightServe» відображає складну структуру взаємозв'язків між власниками, закладами харчування, робітниками, відвідувачами, меню, стравами, столами та замовленнями.

3 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ
3.1 Розробка архітектури системи


Для розробки серверної частини було створено та використано діаграму розгортання, яка є важливою для візуалізації фізичної архітектури системи (див. рис. А.5). Вона дозволяє зрозуміти розташування компонентів та їх зв'язки, що сприяє ефективному проектуванню, аналізу та оптимізації фізичної структури системи. Діаграма розгортання спрощує вивчення взаємодії між компонентами, надаючи повне уявлення про функціональність та залежності.
Також до діаграми розгортання, була створена ще одна діаграма, а саме діаграма станів для користувачів програмної інформаційної системи «LightServe», а саме: власника (див. рис. А.6), робітника (див. рис. А.7) та відвідувача (див. рис. А.8). Ця діаграма визначає можливі стани системи, події, що можуть спричинити переходи між цими станами, і дії, які відбуваються в кожному стані.


3.2 Програмна розробка серверної частини


Для роботи з базами даних було обрано СУБД MS SQL, створено 9 таблиць та створено зв'язки між ними. Для розробки серверної частини було обрано мову програмування С# та технологію ASP.Net Web API.
Для організації архітектури проєкту файли було поділено за папками. Папка «Controllers» містить контролери, які відповідають за обробку HTTP-запитів і взаємодію з моделями в ASP.Net Web API проекті. Папка «Database» містить файл LightServeContext, який відповідає за взаємодію з базою даних. «Interfaces» містить інтерфейси, які використовуються для впровадження принципу впровадження залежностей у проекті. Ці інтерфейси визначають контракти між компонентами системи, що сприяє високому рівню розширюваності та підтримує принцип інверсії залежностей (IoC). Папка "Repositories" містить репозиторії, які реалізовують інтерфейси, що розташовані в папці "Interfaces". Ці репозиторії відповідають за виконання операцій доступу до даних, описаних у відповідних інтерфейсах. Папка "Models" містить моделі, які визначають структуру та властивості даних, використаних у проекті. Ці моделі служать основою для представлення та обробки інформації в системі, а їхні атрибути відображають характеристики об'єктів, з якими працює програма. Папка «Resources» містить ресурси для впровадження локалізації на двох мовах: українська та англійська. 
Розглянемо реалізацію деяких моментів у функціональності серверної частини. 
Реєстрація власника закладу харчування відбувається з використанням його e-mail, який є унікальним для кожного та пароля. Спочатку необхідно перевірити, чи не ввів користувач пустих рядків у поля вводу (див Б.1, рядок 3 ). Далі йде перевірка, чи не існує такого користувача вже у базі даних, якщо так, то виведеться повідомлення, про те що такий користувач вже існує, якщо ні, тоді продовжиться виконання функції реєстрації. Далі відбувається хешування паролю за допомогою бібліотеки BCrypt та методу HashPassword (див Б.1, рядок 12). Після вже створюється екземпляр класу Owner (власник) та за допомогою методу Register додається до бази даних (див Б.1, рядки 14 – 22).
Авторизація власника закладу харчування відбувається з використанням його e-mail, який є унікальним для кожного та пароля. Спочатку необхідно перевірити, чи не ввів користувач пустих рядків у поля вводу (див Б.2, рядок 3). Далі вже за допомогою методу GetOwner отримуються дані власника та йде перевірка чи існує такий користувач, якщо ні, тоді повертається повідомлення, що не знайдено (див Б.2, рядки 5 – 9), якщо так, тоді за допомогою бібліотеки BCrypt та методу Verify (див Б.2, рядок 12) перевіряється чи співпадають пароль, який ввід користувач на етапі реєстрації та етапі авторизації. Якщо ні, то виводиться повідомлення (див Б.2, рядок 14), що пароль неправильний, якщо так, тоді користувач успішно авторизується. 
Реєстрація робітника закладу харчування відбувається таким чином: власник додає робітника у системі і на основі прізвища та імені робітника генерується нікнейм робітника (див Б.3, рядки 8 – 9). Далі йде перевірка чи існує користувач з таким нікнеймом, якщо так тоді до нікнейму додається цифра, починаючи з 1 (див Б.3, рядки 10 – 16). Якщо такого користувача ще не існує далі відбувається генерація пароля за допомогою приватного методу GenerateRandomPassword (див Б.3, рядок 17) розмірами у 12 символів. Далі відбувається хешування паролю за допомогою бібліотеки BCrypt та методу HashPassword (див Б.3, рядок 19). Після вже створюється екземпляр класу Worker (робітник) та за допомогою методу RegisterWorker додається до бази даних (див Б.3, рядки 21 – 30).
Розгляньмо як працює приватний метод GenerateRandomPassword. Спочатку записано у рядок символи, які дозволено використовувати у паролі. Далі за допомогою класу RNGCryptoServiceProvider для отримання випадкових байтів (див Б.4, рядок 4). Потім створюється масив chars, який заповнюється символами, вибраними за допомогою випадкових байтів зі строки allowedChars (див Б.4, рядки 9 – 12). Результатом є новий рядок, який представляє випадковий пароль, і цей рядок повертається методом.


3.3 REST-специфікація


Запити були створені за принципами REST, який є способом доступу до
інформаційних ресурсів через стандартизований підхід. REST використовує
принципи інтернету та HTTP для організації системи, щоб забезпечити
масштабованість, гнучкість та простоту інтеграції між компонентами.
Cafe:
POST /api/Cafe/addCafe - додати новий заклад харчування
GET /api/Cafe/getAllCafes - отримати всі заклади харчування
GET /api/Cafe/getCafeById - отримати заклад харчування за ідентифікатором
DELETE /api/Cafe/deleteCafe - видалити заклад харчування за ідентифікатором
Customer:
POST /api/Customer/register - зареєструвати клієнта
POST /api/Customer/login - авторизувати клієнта
Dish:
POST /api/Dish/addDish - додати нову страву
POST /api/Dish/updateDish - оновити страву
DELETE /api/Dish/deleteDish - видалити страву
GET /api/Dish/getPopularDishes - отримати популярні страви
GET /api/Dish/getDishAmount - отримати кількість страв
Menu:
POST /api/Menu/addMenu - додати нове меню
DELETE /api/Menu/deleteMenu - видалити меню
GET /api/Menu/getAllMenus - отримати всі меню
GET /api/Menu/getMenuById - отримати меню за ідентифікатором
Order:
GET /api/Order/getAllOrders - отримати всі замовлення
GET /api/Order/getOrderById - отримати замовлення за ідентифікатором
POST /api/Order/addOrder - додати нове замовлення
POST /api/Order/addDishToOrder - додати страву до замовлення
DELETE /api/Order/deleteOrder - видалити замовлення
POST /api/Order/changeOrderStatus - змінити статус замовлення
GET /api/Order/getUndoneOrders - отримати незавершені замовлення
DELETE /api/Order/deleteDishFromOrder - видалити страву з замовлення
POST /api/Order/updateDishAmount - оновити кількість страв у замовленні
Owner:
POST /api/Owner/register - зареєструвати власника
POST /api/Owner/login - авторизувати власника
Table:
GET /api/Table/getAllTables - отримати всі столи
POST /api/Table/addTable - додати новий стіл
POST /api/Table/updateTable - оновити стіл
DELETE /api/Table/deleteTable - видалити стіл
Worker:
POST /api/Worker/registerWorker - зареєструвати працівника
POST /api/Worker/login - авторизувати працівника
PUT /api/Worker/resetPassword - скинути пароль працівника
DELETE /api/Worker/deleteWorker - видалити працівника
GET /api/Worker/getAllWorkers - отримати всіх працівників
GET /api/Worker/getWorkerById - отримати працівника за ідентифікатором
